---
layout: post
title: 计算机组成原理总结
date: 2018-3-28
categories: study
tags:
  - MIPS
---

# 第1章 计算机概要与技术

## 1.1 引言

计算机储存容量单位有$2^x$和$10^y$两种形式。比如说`tebibyte`和`terabyte`，前者缩写是`TiB`，是$2^{40}$，后者缩写是`TB`，是$10^{12}$。

计算机主要分成了三大类：个人计算机(PC)、服务器(Server)、嵌入式计算机(Embedded Computer)。其中，许多嵌入式处理器使用的是处理器核(processor core)，是利用硬件描述语言(如Verilog)描述的处理器版本。

在后PC时代(Post PC Era)，个人移动设备(Personal Mobile Device, PMD)替代PC，云计算(cloud computing)替代了传统的服务器。云计算依赖于称为仓储规模计算机(Warehouse Scale Computer, WSC)的巨型数据中心，实现软件即服务(Software as a Service, SaaS)的模式。

云计算有三个重要的概念，分别是软件即服务(Software as a Service, SaaS)、基础设施即服务(Infrastructure as a Service, IaaS)、平台即服务(Platform as a Service, PaaS)，在知乎上有个[答案](https://www.zhihu.com/question/21641778/answer/62523535)很清晰地表述了它们的区别。

简单地说，可以把云计算比作pizza。我们吃到pizza的途径有四种：第一种是在家自己做，那么包括准备原料、制作pizza、吃pizza所需要的工具餐桌都是自己解决的，这个叫本地部署(On-Premises)；第二种是买原料回家做，那么我们只需要制作pizza、准备吃pizza的工具和餐桌，这个叫基础设施即服务(IaaS)；第三种是叫外卖，那我们只需要准备吃pizza的工具和餐桌，这个叫平台即服务(PaaS)；第四种是去pizza店吃，那么我们连工具餐桌都不需要准备，这个叫软件即服务(SaaS)。

也就是说，云计算被简单的分成了三层，基础设施在最底端，平台在中间，软件在顶层。比如说，阿里云的云服务器ECS就是个IaaS，轻量应用服务器就是个PaaS，而各种领域对应的解决方案就是SaaS。

**本书的进阶书籍是《Computer Architecture: A Quantitative Approach》**

一个程序的性能取决于：程序所用算法的有效性、用来建立程序并将其翻译成机器指令的软件系统、计算机执行机器指令(包括I/O操作)的有效性。

```
小测试
1. 支持，嵌入式处理器太多了，比如洗衣机、电视盒子、冰箱、微波炉等等。
2. 所选算法，算法对数据处理的影响太大了，其性能之差是取决于数据规模的。
```

## 1.2 计算机系统结构中的8个伟大思想

* **面向摩尔定律(Moore' Law)的设计**：计算机设计者必须预测其设计完成时的工艺水平，而不是设计开始时的。
* **使用抽象(Abstraction)简化设计**：使用抽象来表示不同的设计层次，在高层次中看不到低层次的细节，只能看到一个简化的模型。
* **加速大概率事件(Common Case Fast)**：通过加速大概率事件而不是优化小概率事件来提高性能。
* **通过并行(Parallel)提高性能**
* **通过流水线(Pipelining)提高性能**：比如，灭火的消防队列是小镇居民排成一排接力将水桶从水源传到火场，而不是每个人来回奔跑。这里流水线就是一系列水管，每一块代表一个流水级(stage)。
* **通过预测提高性能**：假定从误预测恢复执行代价不高并且预测的准确率相对较高。
* **存储器层次(Hierarchy of Memory)**：三角层次，顶端存储器速度快、容量小。
* **通过冗余提高可靠性**：比如，牵引式挂车后轴是双轮胎，一个轮胎出了问题还能继续工作。

## 1.3 程序概念入门

计算机层次：(外层到内)应用软件、系统软件、硬件。

系统软件是提供常用服务的软件，包括操作系统(OS)、编译程序(compiler)、加载程序(loader)和汇编程序(assembler)，其中前两者是现代计算机所必须的。

操作系统是用户程序和硬件之间的接口，为用户提供各种服务和监控功能。作用如下：

* 处理基本的输入、输出
* 分配外存和内存
* 为多个应用程序提供共享计算机资源的服务

编译程序就是我们所说的编译器，将高级语言翻译成硬件能执行的指令。

汇编语言(assembly language)以助记符形式来表示机器指令，而汇编程序可以将汇编语言翻译成二进制程序。

高级编程语言(high-level programming language)可以使程序员用更自然的语言来思考，并且使得程序相对于计算机具有独立性。

```c
// C
void swap(int v[], int k) {
  int temp = v[k];
  v[k] = v[k + 1];
  v[k + 1] = temp;
}
```

```assembly
swap:
  multi $2, $5, 4
  add   $2, $4, $2
  lw    $15, 0($2)
  lw    $16, 4($2)
  sw    $16, 0($2)
  sw    $15, 4($2)
  jr    $31
```

由于没学过MIPS指令集，所以这里暂时看不懂，不过没关系，之后再回来看一下。

## 1.4 硬件概念入门 

计算机的两个关键部件是输入设备(Input Device)和输出设备(Output Device)。

组成计算机的5个经典部件是输入、输出、存储器、数据通路(运算器)、控制器，其中最后两个通常合称处理器。

**显示器(display)**：液晶显示(Liquid Crystal Display, LCD)、冷阴极荧光灯管(Cold Cathode Fluorescent Lamp, CCFL)、发光二极管(Light-Emitting Diode, LED)、有机发光二极管(Organic Light-Emitting Diode, OLED)。需要注意的是，这里的CCFL和LED都是指液晶的背光源，液晶本身是不会发光的，所以需要背光源的支持。LCD和LED不是同一类东西，概念的混淆可以说是宣传的锅。厂商宣传的LED，其实液晶大都还是用LCD，只不过背光源从CCFL改成了LED。不过OLED本身既能发光又能显色，才是用于取代LCD的新技术。

如今大多数LCD显示器采用动态矩阵显示(active matrix display)技术，每个像素(pixel)都由一个晶体管精确控制电流。

图像由像素矩阵组成，可以表示成二进制位的矩阵，称为位图(bit map)。彩色显示是用8位来表示每个三原色(红、绿、蓝)，所以每个像素需要24位。

计算机硬件采用光栅刷新缓冲区(又名帧缓冲区)来保存位图以支持图像。

**触摸屏(touchscreen)**：多是采用电容感应方式。

**CPU(central processor unit)**：中央处理单元，属于集成电路(integrated circuit)，俗称芯片(chip)。

**数据通路(datapath)**：负责完成算术运算。

**控制器(control)**：负责指导数据通路、存储器和I/O设备的正确执行。

**内存(memory)**：即RAM(random access memory)，传统主要分为SRAM(static RAM)和DRAM(dynamic RAM)。前者用锁存器实现，后者用电容实现。现在也有很多新型的RAM，比如阻变式存储器(resistive RAM, RRAM)、铁电存储器(ferroelectric RAM, FRAM)、磁性存储器(magnetic RAM, MRAM)、PRAM。现在的DRAM，一般都是SDRAM(Synchronous DRAM)，支持同步且能自由指定地址进行读写。内存常用DRAM。

**缓存(cache memory)**：常用SRAM，速度比DRAM快，集成度低，更贵。

**应用二进制接口(Application Binary Interface, ABI)**：提供给应用程序员的基本指令集和操作系统接口。

存储器分为易失性存储器(volatile memory)和非易失性存储器(nonvolatile memory)，前者也叫做主存储器(main memory或primary memory)，后者也叫做二级存储器(secondary memory)。二级存储器主要有磁盘(magnetic disk)和闪存(flash memory)。

**局域网(Local Area Network, LAN)**、**广域网(Wide Area Network, WAN)**、万维网(World Wide Web)。`IEEE 802.11`是无线局域网通用标准，目前最新版本是`802.11n`。

```
小测试
       易失性  访问时间   价格
DRAM   Yes    Fastest   Standard
Flash  No     Faster    Cheaper
Disk   No     Standard  Cheapest
```

## 1.5 处理器和存储器制造技术

* 晶体管(transistor)：受电流控制的开关。集成电路(Integrated Circuit, IC)、超大规模集成电路(very large-scale integrated circuit, VLSI)。
* 硅(Silicon)、半导体(semiconductor)、硅锭(silicon crystal ingot)、晶圆(wafer)

$每芯片的价格=\frac{每晶圆的价格}{每晶圆的芯片数*成品率}$

$每晶圆的芯片数\approx\frac{晶圆面积}{芯片面积}$

$成品率=\frac{1}{(1+单位面积的瑕疵数*\frac{芯片面积}{2})^2}$

```
小测试
1、3、4
```

## 1.6 性能

个人计算机用户对**响应时间(response time)**感兴趣，即从开始一个任务到该任务完成的时间，又称执行时间(execution time)。数据中心感兴趣的常常是**吞吐率(throughput)**，也叫带宽(bandwidth)。

$性能_X=\frac{1}{执行时间_X}$

* **CPU执行时间(CPU execution time)**：简称CPU时间，执行某一任务在CPU上所花费的时间。
* **用户CPU时间(user CPU time)**：在程序本身所花费的CPU时间。
* **系统CPU时间(system CPU time)**：为执行程序而花费在操作系统上的时间。

用户所感受到的是程序的响应时间，而不是CPU时间。

**系统性能(system performance)**表示空载系统的响应时间，**CPU性能(CPU performance)**表示用户CPU时间。

时钟间隔的时间称为**时钟周期(clock cycle, tick, period)**，其倒数为**时钟频率(clock rate)**。

```
小测试
1. a同时改进, b只改进响应时间, c没改进
2. 7s
```

$一个程序的CPU执行时间=一个程序的CPU时钟周期数*时钟周期时间$

$一个程序的CPU执行时间=\frac{一个程序的CPU时钟周期数}{时钟频率}$

$CPU时钟周期数=程序的指令数*每条指令的平均时钟周期数$

* **CPI(clock cycle per instruction)**：表示执行每条指令所需的时钟周期数的平均值。
* **IPC(instruction per clock cycle)**：表示每个时钟周期执行的指令数的平均值。

如果一个处理器一个周期执行2条指令，那么IPC=2、CPI=0.5。

$CPU时间=指令数*CPI*时钟周期时间=\frac{指令数*CPI}{时钟频率}$

|         性能的分量          |            测量单位            |
| :-------------------------: | :----------------------------: |
|      程序的CPU执行时间      |     程序执行的执行时间(s)      |
|          指令数目           |       程序执行的指令数目       |
| 指令的平均执行时钟周期(CPI) | 每条指令的平均执行的时钟周期数 |
|        时钟周期时间         |     每个时钟周期的长度(s)      |

唯一能被完全可靠测量的计算机性能指标是时间。

时钟周期时间传统上是固定的，但是有时候可以暂时提高时钟频率，比如Intel的**快速模式(Turbo mode)**。

```
小测试
b
```

## 1.7 功耗墙

CMOS的主要能耗来源是动态能耗，即晶体管开关过程(从0到1或从1到0)产生的能耗。

$能耗 \propto 负载电容 * 电压^2$

$能耗 \propto \frac 12 * 负载电容 * 电压^2$

$功耗 \propto \frac 12 * 负载电容 * 电容^2 * 开关频率$

开关频率是时钟频率的函数，负载电容是连接到输出上的晶体管数量(叫扇出)和工艺的函数，该函数决定导线和晶体管电容。

虽然动态能耗是CMOS能耗的主要来源，但也有静态能耗，即电流泄漏导致的漏电能耗。

## 1.8 沧海巨变：从单处理器向多处理器转变

并行编程的挑战：调度、负载平衡、通讯以及同步等开销。

## 1.9 实例：Intel Core i7基准

**工作负载(workload)**、**基准测试程序(benchmark)**。

SPEC(system performance evaluation cooperative)是由许多计算机销售商共同出资赞助并支持的合作组织，目的是为现代计算机系统建立基准测试程序集。SPEC包含了很多基准程序集，其中关于CPU最新的貌似是CPU2017，相应子程序集有整数基准程序集(CINT)、浮点基准程序集(CFP)。

SPEC ratio是执行时间标准化之后的结果，其值越大，表示性能越快。(SPEC ratio与执行时间的倒数成正比例关系)

SPEC同样有评估功耗的基准测试程序。SPEC  power最早来自面向Java应用的SPEC基准程序(SPEC JBB2005)，在官网查询的结果，SPEC power仍然是2008，但SPEC JBB有2015版本。

## 1.10 谬误与陷阱

**Amdahl定律**：“收益递减定律”的量化版本，阐述了“对于特定改进的性能提升可能由所使用的改进特征的数量所限制”的规则。

$改进后的执行时间=\frac{受改进影响的执行时间}{改进量}+不受影响的执行时间$

**MIPS(million instructions per second)**：每秒百万条指令，有人用其取代以时间度量性能的方法。

$MIPS=\frac{指令数}{执行时间*10^6}$

不过上述MIPS没有考虑指令的能力，所以下面的公式会更准确。

$MIPS=\frac{指令数}{指令数*\frac{CPI}{时钟频率}*10^6}=\frac{时钟频率}{CPI*10^6}$

```
小测试
a. A
b. B
```

---

# 第2章 指令：计算机的语言

## 2.1 引言

计算机语言中的基本单词称为指令，一台计算机的全部指令称为该计算机的**指令集(instruction set)**。

选择MIPS指令教学的理由：

* ARMv7与MIPS类似
* ARMv8更加接近于MIPS，而非ARMv7

|      特性      |                 ARM v8                 |        ARM v7        |
| :------------: | :------------------------------------: | :------------------: |
|     指令集     |          AArch64，兼容AArch32          |       AArch32        |
|  支持地址长度  |                  64位                  |         32位         |
|   通用寄存器   | 31个，x0 - x30(64位)，或w0 - w30(32位) | 15个，r0 - r14(32位) |
|    异常模式    |           4层结构 EL0 - EL3            | 2层结构 vector table |
|      NEON      |                默认支持                |       可选支持       |
|      LAPE      |                默认支持                |       可选支持       |
| Virtualization |                默认支持                |       可选支持       |
|   big.LITTLE   |                  支持                  |         支持         |
|   Trust Zone   |                默认支持                |       默认支持       |
|   SIMD寄存器   |               32个 128位               |      32个 64位       |

**存储程序概念(stored-program concept)**：多种类型的指令和数据均以数字形式存储于存储器中，存储程序型计算机源于此。

## 2.2 计算机硬件的操作

设计三条基本原理：

* 简单源于规整。
* 越小越快。
* 优秀的设计需要适宜的折中方案。

MIPS以`#`作为注释开头。

**MIPS操作数**：

|        名字        |                             示例                             |                             备注                             |
| :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|     32个寄存器     | 以$开头, s0 - s7, t0 - t9, zero, a0 -a3, v0, v1, k0, k1, gp, fp, sp, ra, at | 寄存器用于数据的快速存取。\$zero的值恒为0，\$at被汇编器保留用于处理大的常数 |
| $2^{30}个存储器字$ |        Memory[0], Memory[4], ..., Memory[4294967292]         | 存储器只能通过数据传输指令访问。字地址相差4，储存器用于保存数据结构、数组、溢出的寄存器。 |

**算术指令**：

|        指令         |                     备注                     |
| :-----------------: | :------------------------------------------: |
| `add $s1, $s2, $s3` |           加法，`$s1 = $s2 + $s3`            |
| `sub $s1, $s2, $s3` |           减法，`$s1 = $s2 - $s3`            |
| `addi $s1, $s2, 20` | 立即数加法，用于加常数数据，`$s1 = $s2 + 20` |

**数据传输**：

|        指令        |                             备注                             |
| :----------------: | :----------------------------------------------------------: |
| `lw $s1, 20($s2)`  |                取字，`$s1 = Memory[$s2 + 20]`                |
| `sw $s1, 20($s2)`  |                存字，`Memory[$s2 + 20] = $s1`                |
| `lh $s1, 20($s2)`  |                            取半字                            |
| `lhu $s1, 20($s2)` |                         取无符号半字                         |
| `sh $s1, 20($s2)`  |                            存半字                            |
| `lb $s1, 20($s2)`  |                            取字节                            |
| `lbu $s1, 20($s2)` |                         取无符号字节                         |
| `sb $s1, 20($s2)`  |                            存字节                            |
| `ll $s1, 20($s2)`  | 取链接字(链接加载)，取字作为原子交换(atomic swap)的前半部(1st half) |
| `sc $s1, 20($s2)`  | 存条件字(条件存储)，存字作为原子交换的后半部，`Memory[$s2 + 20] = $s1; $s1 = 0 or 1` |
|   `lui $s1, 20`    | 取立即数的高位(load upper immediate)，`$s1 = 20 * 2 ^ 16`，取立即数并放到高16位 |

MIPS的字是4个字节，并不是x86里面的word才2个字节。

**逻辑**：

|        指令         |                       备注                       |
| :-----------------: | :----------------------------------------------: |
| `and $s1, $s2, $s3` |              与，`$s1 = $s2 & $s3`               |
| `or $s1, $s2, $s3`  |              或，`$s1 = $s2 | $s3`               |
| `nor $s1, $s2, $s3` |            或非，`$s1 = ~($s2 | $s3)`            |
| `andi $s1, $s2, 20` |                     立即数与                     |
| `ori $s1, $s2, 20`  |                     立即数或                     |
| `sll $s1, $s2, 10`  | 逻辑左移(shift left logical)，`$s1 = $s2 << 10`  |
| `srl $s1, $s2, 10`  | 逻辑右移(shift right logical)，`$s1 = $s2 >> 10` |

**条件分支**：

|         指令         |                           备注                            |
| :------------------: | :-------------------------------------------------------: |
|  `beq $s1, $s2, 25`  |     相等时跳转(branch on equal)，`goto PC + 4 + 100`      |
|  `bne $s1, $s2, 25`  |  不相等时跳转(branch on not equal)，`goto PC + 4 + 100`   |
| `slt $s1, $s2, $s3`  | 小于时置位(set on less than)，`$s1 = ($s2 < $s3 ? 1 : 0)` |
| `sltu $s1, $s2, $s3` |     无符号数比较小于时置位(set on less than unsigned)     |
| `slti $s1, $s2, 20`  |                     小于立即数时置位                      |
| `sltiu $s1, $s2, 20` |               无符号数比较小于立即数时置位                |

**无条件跳转**：

|    指令    |                             备注                             |
| :--------: | :----------------------------------------------------------: |
|  `j 2500`  |                   跳转(jump)，`goto 10000`                   |
|  `jr $ra`  | 跳转至寄存器所指位置(jump register)，`goto $ra`，用于switch和过程调用 |
| `jal 2500` | 跳转并链接(jump and link)，`$ra = PC + 4; goto 10000`，用于过程调用 |

## 2.3 计算机硬件的操作数

MIPS体系结构中寄存器大小为32位，32位一组称为**字(word)**。

**数据传送指令(data transfer instruction)**：存储器和寄存器之间传送数据的指令，必须给出存储器地址(address)。

* `lw`：**(load word)**取数指令助记符
* `sw`：**(store word)**存数指令

**偏移量(offset)**、**基址寄存器(base register, index register又叫下标寄存器)**

**对其限制(alignment restriction)**：MIPS字的起始地址必须是4的倍数。

字节寻址：大端法(big-endian)、小端法(little-endian)。MIPS采用的是大端法，x86采用的是小端法，不过值得注意的是，MIPSEL也是小端法的平台。

寄存器溢出(spilling)：将不常使用的变量(或稍后才使用的变量)存回到存储器中的过程。

* `addi`：**(add immediate)**加立即数，支持负常数，所以不需要减立即数的指令。

`$zero`恒置为0，并且其寄存器编号也为0。

```
小测试
非常慢
```

## 2.4 有符号数和无符号数

所有信息都是由**二进制数位(binary digit)**或**位(bit)**组成，取值为高或低、开或关、真或假、1或0。

**最低有效位(least significant bit)**表示最右边的一位(第0位)，**最高有效位(most significant bit)**表示最左边的一位(第31位)。

如果操作结果不能被最右端的硬件位所表示，那么就发生了溢出(overflow)。

区分正数和负数显而易见的解决方案是增加一个独立的符号位，这种表示方法称为符号和幅值(sign and magnitude)表示法。

常用的表示有符号二进制数的方法称为二进制补码(2's complement)。

反码(1's complement)，按位取反。

偏移表示法(biased notation)：通过将数加一个偏移使其具有非负的表示形式。最小的负数是`00...00`，最大的正数是`11...11`，0是`10...00`。

符号扩展(sign extension)：使用符号位填充寄存器的所有剩余位。

* `lb`：(load byte)字节加载
* `lbu`：(load byte unsigned)无符号字节加载

```
小测试
x' + 1 = 1000(2), so x' = 8(10), x = -8(10)
the answer is 2)
```

## 2.5 计算机中指令的表示

在MIPS中，寄存器`$s0` - `$s7`映射到寄存器16 - 23，`$t0` - `$t7`映射到8 - 15。

`add $t0, $s1, $s2`的十进制表示为`0 17 18 8 0 32`。

机器指令分为若干字段(field)，上述的第一个字段和最后一个字段(0和32)组合起来告诉MIPS计算机该指令要完成加法运算。第2、3、4字段是寄存器号，第5字段预留。

指令的布局形式叫做**指令格式(instruction format)**，从位的数目上看，MIPS指令占32位。与x86为了兼容而不等长的指令集不一样，所有MIPS指令都是32位长。

指令的数字形式称为**机器语言(machine language)**，这样的指令序列叫作**机器码(machine code)**。

**MIPS R型指令格式**：

|       op       |          rs           |           rt           |          rd          |    shamt     |  funct   |
| :------------: | :-------------------: | :--------------------: | :------------------: | :----------: | :------: |
| 操作码(opcode) |    第一个源寄存器     |     第二个源寄存器     |      目的寄存器      |    位移量    |  功能码  |
|   operation    | first register source | second register source | register destination | shift amount | function |
|      6位       |          5位          |          5位           |         5位          |     5位      |   6位    |

**MIPS I型指令格式**：

|   op   |    rs    |    rt    | constant or address |
| :----: | :------: | :------: | :-----------------: |
| 操作码 | 源寄存器 | 汇寄存器 |    立即数或偏移     |
|  6位   |   5位    |   5位    |        16位         |

**MIPS指令**：

|         指令          | 格式 |    op     |         shamt         |   funct   |
| :-------------------: | :--: | :-------: | :-------------------: | :-------: |
|         `add`         |  R   |     0     |           0           | $32_{10}$ |
|    `sub`(subtract)    |  R   |     0     |           0           | $34_{10}$ |
| `addi`(add immediate) |  I   | $8_{10}$  | n. a.(not applicable) |   n. a.   |
|    `lw`(load word)    |  I   | $35_{10}$ |         n. a.         |   n. a.   |
|   `sw`(store word)    |  I   | $43_{10}$ |         n. a.         |   n. a.   |

```
小测试
op == 0 && funct == 32 # instruction => sub
rd == 10               # dest => $t2
rs == 8 && rt == 9     # src => $t0, $t1
# => sub $t2, $t0, $t1
the answer is 4
```

## 2.6 逻辑操作

MIPS使用一个操作数为0的`nor`指令实现取反操作。

shamt字段在移位指令中被用于表示**移位量(shift amount)**。

**MIPS指令**：

| 指令  |  op  |  rs  |  rt  |  rd  | shamt | funct |
| :---: | :--: | :--: | :--: | :--: | :---: | :---: |
| `sll` |  0   |  0   | reg  | reg  | bits  |   0   |

`and`提供了一种将源操作数中某些位置为0的能力，前提是另一个操作数中对应位为0。后一个操作数传统上被称为**掩码(mask)**。`or`就是置1的能力。

MIPS引入了或非`nor`(not or)指令来取代NOT，为了保持三操作数的格式。(`a nor 0 == not a`)，`nor`没有立即数版本。

`xor`：异或。

```
小测试
the answer is 2
```

## 2.7 决策指令

**条件分支(conditional branch)**指令：

* `beq reg1, reg2, label`：branch if equal
* `bne reg1, reg2, label`：branch if not equal

**无条件分支(unconditional branch)**指令：

* `j label`：jump

**while循环**：

```c
while (save[i] == k) i++;
```

假设i和k存放在`$s3`和`$s5`中，数组save的基址存放在`$s6`中。

```assembly
#
# while $s3($s6) == $s5
#   $s3++
#   print "i++\n"
# end

  .data
message:  .asciiz "i++\n"
array:    .word 1, 1, 1, 1, 0, 0, 0
  .text
main:
  # syscall setting
  li      $v0, 4
  la      $a0, message
  # initial
  li      $s3, 0 # i
  li      $s5, 1 # k
  la      $s6, array # save
DO_WHILE:
  sll     $t0, $s3, 2
  add     $t0, $t0, $s6
  lw      $t0, 0($t0)
  bne     $t0, $s5, END_WHILE
  syscall
  addi    $s3, $s3, 1
  j       DO_WHILE
END_WHILE:
  nop
```

这里的`li`是宏指令，比如13行的`li $v0, 4`会被展开为`addi $v0, $zero, 4`。这里的`la`是伪指令，是用来取标签地址的。

这里利用了一个叫`SPIM`的MIPS模拟器来测试代码(菜秀用了 `QtSPIM`)，其中要注意的是，`SPIM`需要设置为`Simple Machine`，而不是`Bare Machine`。

 **基本块(basic block)**是没有分支(可能出现在末尾者除外)并且没有分支目标/分支标签(可能出现在开始者除外)的指令序列。

* `slt`：set on less than，有符号
* `slti`：set on less than immediate，有符号
* `sltu`：无符号
* `sltiu`：无符号

将有符号数作为无符号数来处理，是一种检验$0 \le x \lt y$的低开销方法，常用于检查数组下标是否越界。

MIPS可以通过`slt`、`slti`、`beq`、`bne`和`$zero`来创建所有的比较条件：相等、不等、小于、小于等于、大于、大于等于。因此基于`RISC`的原则，MIPS没有提供“小于则分支”的指令。

**case/switch语句**：

实现switch语句的最简单方法是借助一系列的条件判断，将switch语句转化为if-then-else语句嵌套。

另一种更有效的方法是将多个指令序列分支的地址编码为一张表，即**转移地址表(jump address table)**或**转移表(jump table)**，程序只需索引该表即可跳转到恰当的指令序列。转移地址表是一个由代码中标签所对应地址构成的数组。

* `jr`：jump register，寄存器跳转指令。

```
小测试
I. 1, 2, 3
II. 3
```

## 2.8 计算机硬件对过程的支持

**过程(procedure)**：根据提供的参数执行一定任务的储存的子程序。

程序必须遵循以下6个步骤：

1. 将参数放在过程可以访问的位置
2. 将控制交给过程
3. 获得过程所需的存储资源
4. 执行需要的任务
5. 将结果的值放在调用程序可以访问的位置
6. 将控制返回初始的点，因为一个过程可能由一个程序中的多个点调用

MIPS软件在为过程调用分配32个寄存器时遵循以下约定：

* `$a0` ~ `$a3`：用于传递参数的4个参数寄存器
* `$v0` ~ `$v1`：用于返回值的两个值寄存器
* `$ra`：用于返回起始点的返回地址寄存器

过程调用指令：跳转到某个地址的同时将下一条指令的的地址保存在寄存器`$ra`中。这条**跳转和链接指令(jump-and-link instruction)**的格式为`jal ProcedureAddress`，存储在`$ra`(31号寄存器)中的链接部分称为**返回地址(return address)**。

调用程序称为**调用者(caller)**，将参数值放到`$a0` - `$a3`中，然后使用`jal X`跳转到过程X(**被调用者(callee)**)。被调用者执行运算，将结果放到`$v0`和`$v1`，然后使用`jr $ra`将控制返回给调用者。

**程序计数器(program counter)**，保存当前运行的指令地址。

* `$sp`：栈指针(stack pointer)寄存器，第29号寄存器，以字为单位进行调整。按照历史惯例，栈“增长”是按照地址从高到低的顺序进行。数据压栈时，栈指针值减小

```c
int leaf_example(int g, int h, int i, int j) {
  return (g + h) - (i + j);
}
```

我们可以写出如下的代码：

```assembly
leaf_example:
  # 分配3个空间储存寄存器旧值
  addi $sp, $sp, -12
  sw   $t1, 8($sp)
  sw   $t0, 4($sp)
  sw   $s0, 0($sp)
  # 函数体
  add  $t0, $a0, $a1
  add  $t1, $a2, $a3
  sub  $s0, $t0, $t1
  add  $v0, $s0, $zero
  # 恢复寄存器旧值
  lw   $s0, 0($sp)
  lw   $t0, 4($sp)
  lw   $t1, 8($sp)
  addi $sp, $sp, 12
  jr   $ra
  nop
```

MIPS将18个寄存器分为两组：

* `$t0` ~ `$t9`：10个临时寄存器，不必被调用者保存
* `$s0` ~ `$s7`：8个保留寄存器，必须被保存

叶过程(leaf procedure)：不调用其他过程的过程。

```c
int fact(int n) {
  if (n < 1) return 1;
  return n * fact(n - 1);
}
```

调用非叶过程时需要额外压栈：

```assembly
fact:
  addi $sp, $sp, -8
  sw   $ra, 4($sp)
  sw   $a0, 0($sp)
  slti $t0, $a0, 1
  beq  $t0, $zero, L1
  addi $v0, $zero, 1
  addi $sp, $sp, 8
  jr   $ra
L1:
  addi $a0, $a0, -1
  jal  fact
  lw   $a0, 0($sp)
  lw   $ra, 4($sp)
  addi $sp, $sp, 8
  mul  $v0, $a0, $v0
  jr   $ra
  nop
```

C语言包括两种存储方式：动态(automatic)、静态(static)。动态变量位于过程中，当过程退出时失效；静态变量在进入和退出过程时始终存在。

* `$gp`：全局指针(global pointer)，指向静态数据区的保留寄存器
* `$fp`：帧指针(frame pointer)，指向过程帧的第一个字，为局部存储器引用提供一个固定的基址寄存器

栈中包含过程所保存的寄存器和局部变量的片段称为**过程帧(procedure frame)**或**活动记录(activation record)**。

MIPS内存低端第一部分保留，之后是**代码段(text segment)**，代码段之上是**静态数据段(static data segment)**，是存储常量和其他静态变量的空间(习惯上称为**堆heap**)。

|    名称     | 寄存器号 |         用途         | 调用时是否保存 |
| :---------: | :------: | :------------------: | :------------: |
|   `$zero`   |    0     |        常数0         |     不适用     |
| `$v0`~`$v1` |   2~3    | 计算结果和表达式求值 |       否       |
| `$a0`~`$a3` |   4~7    |         参数         |       否       |
| `$t0`~`$t7` |   8~15   |       临时变量       |       否       |
| `$s0`~`$s7` |  16~23   |     保存的寄存器     |       是       |
| `$t8`~`$t9` |  24~25   |     更多临时变量     |       否       |
| `$k0`~`$k1` |  26~27   |    为操作系统保留    |                |
|    `$gp`    |    28    |       全局指针       |       是       |
|    `$sp`    |    29    |        栈指针        |       是       |
|    `$fp`    |    30    |        帧指针        |       是       |
|    `$ra`    |    31    |       返回地址       |       是       |

帧指针不是必须的，GNU MIPS C编译器使用帧指针，但是MIPS的C编译器将寄存器30看作`$s8`。

```c
int sum(int n, int acc) {
  if (n > 0) return sum(n - 1, acc + n);
  return acc;
}
```

尾调用(tail call)、尾迭代(tail recursion)：

```assembly
# $a0 = n, $a1 = acc
sum:
  slti $t0, $a0, 1 # if n <= 0
  bne  $t0, $zero, sum_exit
  add  $a1, $a1, $a0
  addi $a0, $a0, -1
  j    sum
sum_exit:
  add  $v0, $a1, $zero
  jr   $ra
  nop
```

```
小测试
1, 2都是正确的
```

## 2.9 人机交互

`!(@|=>`，wow open tab at bar is great。

* `lb`：load byte，从内存中读出一个字节，并将其放在一个寄存器最右边的8位
* `sb`：store byte，把一个寄存器最右边的8位取出来然后写到内存中

表示一个字符串的方式有三种选择：

1. 保留字符串的第一个位置用于给出字符串的长度
2. 附加一个带有字符串长度的变量，如在结构体中
3. 字符串最后的位置用一个字符来标识其结尾

```c
void strcpy(char x[], char y[]) {
  int i = 0;
  while ((x[i] = y[i]) != '\0') {
    i++;
  }
}
```

假定x和y的基地址存储在`$a0`和`$a1`中，i存储在`$s0`中。

```assembly
strcpy:
  addi $sp, $sp, -4
  sw   $s0, 0($sp)
  add  $s0, $zero, $zero
L1:
  add  $t1, $s0, $a1
  lbu  $t2, 0($t1)
  add  $t1, $s0, $a0
  sb   $t2, 0($t1)
  beq  $t2, $zero, L2
  addi $s0, $s0, 1
  j    L1
L2:
  lw   $s0, 0($sp)
  addi $sp, $sp, 4
  jr   $ra
  nop
```

`strcpy`是一个叶过程，可以将i放在临时寄存器中以避免对`$s0`进行保存和恢复。

`Unicode 4.0`版本有超过160个“块”，每个块是一个符号集的名字，且是16的整数倍。默认是16位编码，称为`UTF-16`。`UTF-8`是一种变长编码，将ASCII子集保持为8位，其余符号用16或32位来表示。`UTF-32`使用32位来表示一个字符。

* `lh`：load half，从存储器中读出一个半字，将其放在寄存器的最右边16位
* `lhu`：load half word unsigned，将半字看作无符号数
* `sh`：store half，将寄存器最右边16位写入存储器

与C不同，Java的字符串是一个类，其包含一个字来给出字符串的长度，与Java数组相似。

MIPS软件试图保持栈和字地址的对齐，这一约定意味着一个char类型变量在栈中被分配4字节，不过通常C会将4字节压缩1字，Java将2半字压缩为1字。

```
小测试
I. 1
II. 3
```

## 2.10 MIPS中32位立即数和寻址

* `lui`：load upper immediate，设置寄存器中常数的高16位
* `ori`：立即数或，常用来设置低16位

**MIPS J型指令格式**：

|     op     | address |
| :--------: | :-----: |
| 跳转操作码 |  地址   |
|    6位     |  26位   |

**MIPS 条件分支指令格式**：

|   op   | register 1 | register 2 | address  |
| :----: | :--------: | :--------: | :------: |
| 操作码 |  操作数1   |  操作数2   | 分支地址 |
|  6位   |    5位     |    5位     |   16位   |

**PC相对寻址(PC-relative addressing)**：用PC作为增加地址的寄存器，这事加速大概率事件的一个例子。其地址被设计为字地址，所以26位字地址可以表示28位字节地址，最大寻址256MB。

跳转超出范围的解决方法：插入一个跳转到分支目标的无条件跳转，并将条件取反以便由分支决定是否跳过该无条件跳转指令。

**MIPS的5种寻址模式(addressing mode)**：

|  寻址模式  |           格式            | 操作数 |      地址       |
| :--------: | :-----------------------: | :----: | :-------------: |
| 立即数寻址 |     `op-rs-rt-立即数`     | 立即数 |      常数       |
| 寄存器寻址 | `op-rs-rt-rd-shamt-funct` | 寄存器 |     寄存器      |
|  基址寻址  |    `op-rs-rt-形式地址`    |  内存  |   寄存器+常数   |
| PC相对寻址 |    `op-rs-rt-形式地址`    |  内存  |     PC+常数     |
| 伪直接寻址 |       `op-形式地址`       |  内存  | PC高位+26位字段 |

检查**核心转储(core dump)**时，必须通过逆向工程将机器语言恢复到最初的汇编语言。

```
小测试
I.   3
II.  6
III. 6
```

## 2.11 并行与指令：同步

**数据竞争(data race)**：假如来自不同线程的两个访存请求访问同一个地址，它们连续出现，并且至少其中一个是写操作。

采用加锁(lock)和解锁(unlock)可以直接创立一个仅允许单个处理器操作的区域，叫作互斥(mutual exclusion)区。

**原子交换原语(atomic exchange或atomic swap)**：将寄存器中的一个值和存储器中的一个值相互交换。

原子交换可行的方法是采用指令对，其中第二条指令返回一个表明这对指令是否原子执行的标志值。在MIPS中这一指令对包含**链接取数(load linked)**的特殊取数指令和**条件存数(store conditional)**的特殊存数指令。

```assembly
again:
    addi    $t0, $zero, 1            ;copy locked value
    ll      $t1, 0($s1)
    sc      $t0, 0($s1)
    beq     $t0, $zero, again
    addi    $s4, $zero, $t1
```

在`ll`和`sc`两条指令之间的任何时候有处理器插入，并修改了该锁单元的值，指令`sc`会将`$t0`置为0，引起这段指令序列重新执行。`$s4`、`$s1`指向的锁单元的值发生了原子交换。

在单处理器中，为了保证执行不被任何事件所干扰，条件存数指令在处理器两条指令之间进行**上下文切换(context switch)**时也会失败。

链接取数/条件存数机制的优点时：可以通过它们来构造其他的诸如**原子比较和交换(atomic compare and swap)**或者**原子取后加(atomic fetch-and-increment)**等同步原语。

```
小测试
1
```

## 2.12 翻译并执行程序

**伪指令(pseudo instruction)**：

* `move`：有寄存器`$zero`所生成的指令，功能是将一个寄存器中的内容复制到另一个中。
* `blt`：branch on less than，将转换成`slt`和`bne`，相似的指令还有`bgt`、`bge`、`ble`。
* MIPS允许将32位常量加载到一个寄存器中

**符号表(symbol table)**：一个用来匹配标记名和指令所在内存字的地址的列表。

UNIX系统中的目标文件包含6个部分：

* 目标文件头，描述目标文件其他部分的大小和位置
* 代码段，包含机器语言代码
* 静态数据段，包含在程序生命周期内分配的数据
* 重定向信息，标记了一些在程序加载进内存时依赖于绝对地址的指令和数据
* 符号表，包含未定义的剩余标记，如外部引用
* 调试信息，包含一份说明目标模块如何编译的简明描述


**链接器(linker)**：

1. 将代码和数据模块象征性地放入内存
2. 决定数据和指令标签的地址
3. 修补内部和外部引用

**加载器(loader)**：

1. 读取可执行文件头来确定代码段和数据段的大小
2. 为正文和数据创建一个足够大的地址空间
3. 将可执行文件中的指令和数据复制到内存中
4. 把主程序的参数(如果存在)复制到栈顶
5. 初始化机器寄存器，将栈指针指向第一个空位置
6. 跳转启动例程，将参数复制到参数寄存器并调用程序的main函数。当main函数返回时，启动例程通过系统调用exit终止程序


**动态链接库(dynamically linked library，DLL)**：

DLL的晚过程链接(lazy procedure linkage)版本中，每个例程只有再它被调用后才被链接。

```
小测验
4
```

## 2.13 以一个C排序程序作为完整的例子

```c
void swap(int v[], int k) {
    int temp = v[k];
    v[k] = v[k + 1];
    v[k + 1] = temp;
}
```

```c
void sort(int v[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i - 1; j >= 0 && v[j] > v[j + 1]; j--) {
            swap(v, j);
        }
    }
}
```

中断~

---

# 第4章 处理器

## 4.1 引言

计算机的性能由三个关键因素决定：指令数目、时钟周期长度、每条指令所需时钟周期数(CPI)。

**一个基本的MIPS实现**：

* 存储器访问指令：`lw`、`sw`
* 算术逻辑指令：`add`、`sub`、`and`、`or`、`slt`
* 分支指令：`beq`、`j`

**多选器(multiplexor)**：数据选择器，从不同的数据来源中选择一个送给目标单元。

## 4.2 逻辑设计的一般方法

MIPS实现中的数据通路功能部件包括两种不同的逻辑单元，处理数据值的单元和存储状态的单元。处理数据值的单元都是**组合单元(combinational element)**，它们的输出只取决于当前的输入。设计中的其他单元是非组合单元，包含状态，**状态单元(state element)**。

**时钟方法(clocking methodology)**规定了信号可以读出和写入的时间，为简单起见，我们采用**边沿触发的时钟(edge-triggered clocking)**，即在时序逻辑单元中存储的所有值都只允许在时钟跳变的边沿时改变。

```
小测试
错，边沿触发状态单元可以同时进行读写
```

## 4.3 建立数据通路

**数据通路部件**：指令存储器、数据存储器、寄存器堆、ALU和加法器。

**寄存器堆(register file)**：寄存器集合，通过指定寄存器号来读写寄存器。

**符号扩展(sign-extend)**：将偏移地址恢复为存储单元地址。

在实际MIPS指令集中，分支指令是`延迟的`，即无论分支条件是否满足，它之后的指令总是被执行。将分支指令设为延迟的原因是减轻流水线对分支指令的影响。

```
小测试
I.  a
II. c
```

## 4.4 一个简单的实现机制

MIPS ALU在4位控制信号上定义了6种有效的输入组合：

| ALU控制信号 | 功能 | ALU控制信号 |    功能    |
| :---------: | :--: | :---------: | :--------: |
|    0000     |  与  |    0110     |     减     |
|    0001     |  或  |    0111     | 小于则置位 |
|    0010     |  加  |    1100     |    或非    |

使用一个小的控制单元即可生成4位的ALU控制信号，其输入为指令的funct字段和2位的ALUOp字段。ALUOp指明要进行的操作是存取指令需要的加法(00)、beq需要的减法(01)，还是由指令的funct字段(10)决定。该ALU控制单元输出4位信号。

这种多级译码的方法是一种常用的实现方法，即主控制单元生成ALUOp作为ALU控制单元的输入，再由ALU控制单元生成真正控制ALU的信号。

## 4.5 流水线概述

**流水线(pipelining)：**一种实现多条指令重叠执行的技术。

一个MIPS指令包含如下5个处理步骤：

1. 从指令存储器中读取指令。
2. 指令译码的同时读取寄存器，MIPS的指令格式允许同时进行指令译码和读寄存器。
3. 执行操作或计算地址。
4. 从数据存储器中读取操作数。
5. 将结果写回寄存器。

所有的流水级(pipeline stage)都只花费一个时钟周期的时间，因此，时钟周期必须能够满足最慢操作的执行需要。

$指令执行时间_{流水线} = \frac{指令执行时间_{非流水线}}{流水线级数}$

流水线所带来的性能提高是通过增加指令的吞吐率，而不是减少单条指令的执行时间实现的。

流水线在下一个时钟周期中下一条指令不能执行，这种情况被称为**冒险(hazard)**：

* **结构冒险(structural hazard)**：硬件不支持多条指令在同一时钟周期执行。
* **数据冒险(data hazard)**：由于一条指令必须等待另一条指令的完成而造成流水线的暂停的情况。需要**前推(forwarding)**或**旁路(bypassing)**来从内部资源中直接提前的到缺少的运算项。
* **控制冒险(control hazard)**：也叫分支冒险，决策依赖于一条指令的结果，而其他指令正在执行。

流水线在遇到**取数-使用型数据冒险(load-use data hazard)**时，需使用**流水线阻塞(pipeline stall)**(气泡bubble)来阻塞一个步骤。

解决分支问题的方法：

* 阻塞(stall)
* 预测(predict)：预测正确时不会降低流水线的速度，预测错误就不得不重新执行指令。常用简单预测和分支预测
* 延迟分支：在分支指令后紧跟一条不受该分支影响的指令

## 4.6 流水线数据通路及其控制

因为任何一个单时钟周期内，最多会执行5条指令，因此必须把数据通路分成5个部分：

1. IF：取数据
2. ID：指令译码，读寄存器堆
3. EX：执行或计算地址
4. MEM：数据存储器访问
5. WB：写回

从左到右的指令流中有两个例外：

* 写回阶段，它把结果写回数据通路中间的寄存器堆中。导致数据冒险
* 选择PC的下一个值时，需在自增的PC和MEM级的分支地址间选择。导致控制冒险

## 4.7 数据冒险：旁路与阻塞

直接采用总是旁路的方式解决冒险是不正确的，因为某些指令可能不写回寄存器，就会产生一些不必要的旁路。一种简单的解决方法是检测RegWrite信号是否活动的，即通过检测流水线寄存器在EX和MEM级的WB控制字段以确定RegWrite是否被有效。

当一条指令试图读取一个由前一条装载指令读入的寄存器时，就无法使用旁路解决冒险了，必须采用相应的机制阻塞流水线。因此，除了一个旁路单元以外，还需要一个冒险检测单元，它工作在ID级，从而可以在装载指令与紧随其后需要它的结果的指令间插入阻塞。

如果处于ID级的指令被阻塞，那么处于IF级的指令也必须被阻塞，否则，已经取到的指令就会丢失。防止这两条指令继续执行的方法是保持PC寄存器和IF/ID流水线寄存器不变，这样IF级继续使用相同的PC取指令，ID级继续使用相同的指令读寄存器堆，即相当于**空指令(nop)**。

## 4.8 控制冒险

为了确保预取正确指令而导致的延迟叫作**控制冒险(control hazard)**或**分支冒险(branch hazard)**。

一种比较普遍的提高速度的方法是假设分支不发生，并继续执行顺序的指令流。如果分支发生，就丢弃已经读取并译码的指令。为了丢弃指令，只需要将最初的控制信号置为0即可。分支冒险中的丢弃指令意味着必须能够将流水线的IF、ID和EX级的指令都**清除(flush)**。

一种提高分支效率的方法是缩短分支的执行时间。MIPS体系结构是面向支持快速的单周期分支设计的，简单的PC判断并不需要完整的ALU操作。为了将分支决策提前，需要提前两个动作：计算分支目标地址、判断分支条件。分支目标地址的计算只需从EX级移到ID级，判断分支条件需要比较从ID级取到的两个寄存器的值，先异或操作判断相等，然后将结果按位或。为了把分支条件判断提前到ID级，还需要额外的旁路和冒险，因为分支条件的判断可能依赖还在流水线中的结果。

一种策略是通过查找指令的地址观察上一次执行该指令时分支是否发生，如果上一次分支发生，就从上一次分支发生的地方开始取新的指令，这种计算称为**动态分支预测(dynamic branch prediction)**。这种策略的一种实现方法就是采用**分支预测缓存(branch prediction buffer)**或**分支历史记录表(branch history table)**。

## 4.9 异常

控制中的**异常(exception)**和**中断(interrupt)**，是除分支以外改变正常指令执行顺序的事件。异常是打断程序正常执行的突发事件，用于检测溢出等；中断是来自处理器外部的异常。

异常发生时处理器必须执行的操作：在**异常程序计数器(Exception Program Counter, EPC)**中保存出错指令的地址，并把控制权转交给操作系统的特定地址。

用于表示产生异常的原因有两个方法：MIPS使用的方法时设置一个状态寄存器(Cause寄存器)，其中一个字段用于记录异常产生的原因；另一个方法是**向量中断(vectored interrupt)**，控制权被跳转到由异常原因决定的地址。

在流水线实现中，异常可被视作另一种形式的控制冒险，如果产生异常，必须清除流水线中的一系列指令，并从新的地址开始取址。

处理分支预测错误时：IF级指令转换成`nop`；ID级指令用已有的多选器将控制信号清零以产生阻塞，一个称为ID.Flush的新控制信号与冒险检查单元阻塞信号相或；EX级指令同样使用EX.Flush的新信号控制新的多选器将控制信号清零。

许多异常需要我们能够正常执行引起异常的指令，做到这一点最简单的方法时先清除这条指令，然后在异常处理完成后再重新执行这条指令。

## 4.10 指令级并行

**流水线**挖掘了指令间潜在的并行性，这种并行性被称为**指令级并行(instruction-level parallelism, ILP)**。有两种方法可以增加潜在的指令级并行程度：第一是增加流水线的深度以重叠更多的指令；第二是复制计算机内部部件的数量，使得每个流水级可以启动多条指令，这个被称为**多发射(multiple issue)**。

实现一个多发射器主要有两种方式，其区别是将主要工作分给编译器来做还是硬件来做：**静态多发射**(static multiple issue)、**动态多发射**(dynamic multiple issue)。

**推测(speculation)**是一种寻找和挖掘更大ILP的最重要的方法，是一种为了使依赖于被推测指令的其他指令可以执行而允许编译器或处理器“猜测”指令结果的方法。

**发射包(issue packet)**可被视为一条完成多个操作的长指令，其是在给定时钟周期内的多条指令的集合，又称为**超长指令字(Very Long Instruction Word，VLIW)**。简单的双发射MIPS处理器，一条指令时整型ALU操作或分支，另一条指令时装载指令或存储指令。

装载指令有一个时钟周期的**使用延迟(use latency)**，因此下一个发射包不能无阻塞地使用装载地结果。而且，原本在简单五级流水线中没有延迟地ALU指令现在有一个周期地使用延迟。

有一种重要地从循环中获得更多性能地编译技术叫**循环展开(loop unrolling)**，展开后通过重叠不同循环体中的指令可以获得更高的指令级并行(ILP)。在循环展开过程中，编译器引入临时寄存器，这个过程被称为**寄存器重命名(register renaming)**，目的时消除一些虚假的数据依赖。

## 4.11 实例：ARM Cortex-A8和Intel Core i7流水线

ARM Cortex-A8采用动态多发射技术，每个时钟周期可以发射两条指令，其流水线为静态顺序流水线，指令发射、执行和提交顺序执行。

x86采用了复杂的流水线技术，在其14级流水线中综合使用了动态多发射、乱序执行和推测执行的动态流水线调度技术。Intel取入x86指令，将其翻译为类MIPS指令，称之为“微操作”。Intel Core i7使用重排序缓冲区和寄存器重命名技术来解决反相关和推测错误。
